[TOC]

## 浏览器页面渲染

> 页面渲染的过程

1. 浏览器根据DNS域名解析得到IP地址
2. 根据IP地址发起HTTP请求
3. 服务器根据请求HTTP请求
4. 浏览器得到返回的内容
5. 解析HTML，生成DOM树
6. 解析CSS，生成CSS Rule Tree
7. 构建：合并DOM和CSS树，将其合并为rendering Tree(渲染树)
8. 布局：根据渲染树，计算出每个元素在页面中的位置
9. 绘制：把渲染树上的元素展示到浏览器上



> 渲染阻塞

确保在脚本执行前页面已经完成了DOM树渲染。

> 重排



> 重绘

## 伪数组 伪数组转化为数组

有length和索引，但是没有数组的方法

转化为数组：

1. Array.from（***）
2. 通过 call 调用数组的 slice 方法来实现转换
3. ...扩展运算符

## 检测数据类型

typeof：其中数组、对象、null都会被判断为object

instanceof：内部运行机制是判断在其原型链中能否找到该类型的原型

可以看到，`instanceof`只能正确判断引用数据类型，而不能判断基本数据类型。`instanceof` 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 `prototype` 属性。

## typeof NaN的结果

NaN 指“不是一个数字”（not a number），结果是number，是唯一一个===不成立的值，是自反值

## let、var和const

<img src="C:\Users\10153\AppData\Roaming\Typora\typora-user-images\image-20211201210935507.png" alt="image-20211201210935507" style="zoom:50%;" />

## 临时死区

js引擎扫描发现变量声明，要么提升至作用域最前面，要么放到临时死区里(let和const的声明)，直到遇到声明语句，才把变量从临时死区里拿出来

## 为什么要提升

> 变量提升：由于第一代JS虚拟机中的抽象纰漏导致的，编译器将变量放到了栈槽内并编入索引，然后在（当前作用域的）入口处将**变量名**绑定到了**栈槽内**的变量。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。）

变量提升是人为实现的纰漏，而函数提升在当初设计时是有目的的。

函数提升就是为了解决相互递归的问题

## es6新特性

### let和const

### 默认参数

> es5的时候：

非严格模式：arguments随传入参数的改变而改变

严格模式：参数改变不影响arguments的值

> es6

使用默认参数，不管是严格模式还是非严格模式，参数改变都不……

并且如果有两个参数，一个参数有默认参数，则arguments[1]的值是undefined

### 解构赋值

### 剩余参数

### 箭头函数

### promise异步编程



