[TOC]

## 浏览器页面渲染

> 页面渲染的过程

1. 浏览器根据DNS域名解析得到IP地址
2. 根据IP地址发起HTTP请求
3. 服务器根据请求HTTP请求
4. 浏览器得到返回的内容
5. 解析HTML，生成DOM树
6. 解析CSS，生成CSS Rule Tree
7. 构建：合并DOM和CSS树，将其合并为rendering Tree(渲染树)
8. 布局：根据渲染树，计算出每个元素在页面中的位置
9. 绘制：把渲染树上的元素展示到浏览器上

> 浏览器渲染进程

分为两个线程：GUI线程、JS引擎线程。

GUI线程主要负责：渲染浏览器页面，解析HTML、CSS并构建DOM树和							      渲染树；进行页面的绘制和布局。

JS引擎线程主要负责：解析Java Script脚本；按照代码顺序一次把代码添									  加到执行队列中（除了计时器），一个浏览器渲染									  进程里同时只能有一个JS引擎在运作（JS是单线程									  的）。

两个线程是互斥的，当JS引擎线程执行时，GUI线程会被挂起，直到JS引擎线程执行完毕。

另外，CSS文件的下载解析也会阻碍HTML的下载解析

> 渲染阻塞

CSS和JS代码的加载解析阻塞DOM树的构建。

~~JS引擎进程长时间运行，GUI线程长时间挂起，导致页面渲染不连贯。~~

解决：确保在脚本执行前页面已经完成了DOM树渲染。

​	方案1：把CSS放在head标签里，js代码放在文档的末尾

> 重排

元素位置、文本内容结构发生改变时，会发生重排。（重排一定会导致重绘）。如：DOM对元素进行增删或者位置排列，元素大小改变、CSS改变属性样式

> 重绘

不改变元素在浏览器中的排列位置，而只是对背景色、边框色、元素的显隐进行操作时，会发生页面的一部分重绘。

## 伪数组 伪数组转化为数组

有length和索引，但是没有数组的方法

转化为数组：

1. Array.from（***）
2. 通过 call 调用数组的 slice 方法来实现转换
3. ...扩展运算符

## 检测数据类型

typeof：其中数组、对象、null都会被判断为object

instanceof：内部运行机制是判断在其原型链中能否找到该类型的原型

可以看到，`instanceof`只能正确判断引用数据类型，而不能判断基本数据类型。`instanceof` 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 `prototype` 属性。

## typeof NaN的结果

NaN 指“不是一个数字”（not a number），结果是number，是唯一一个===不成立的值，是自反值

## 什么是闭包

变量或函数，在定义其的作用于之外，仍然可以访问到原作用域（原作用域仍因为他的存在而保留）

例子：

```javascript
```



## es6新特性

### let和const

和var的区别

<img src="C:\Users\10153\AppData\Roaming\Typora\typora-user-images\image-20211201210935507.png" alt="image-20211201210935507" style="zoom:50%;" />

### 默认参数

> es5的时候：

非严格模式：arguments随传入参数的改变而改变

严格模式：参数改变不影响arguments的值

> es6

使用默认参数，不管是严格模式还是非严格模式，参数改变都不……

并且如果有两个参数，一个参数有默认参数，则arguments[1]的值是undefined

### 解构赋值

### 剩余参数

### 箭头函数

1. 没有arguments
2. 没有this绑定
3. prototype属性，不可以作为构造函数创建对象

### promise异步编程

## 临时死区

js引擎扫描发现变量声明，要么提升至作用域最前面，要么放到临时死区里(let和const的声明)，直到遇到声明语句，才把变量从临时死区里拿出来

## 为什么要变量提升

> 变量提升：由于第一代JS虚拟机中的抽象纰漏导致的，编译器将变量放到了栈槽内并编入索引，然后在（当前作用域的）入口处将**变量名**绑定到了**栈槽内**的变量。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。）

变量提升是人为实现的纰漏，而函数提升在当初设计时是有目的的。

函数提升就是为了解决相互递归的问题

## 尾调优化

es6引擎的优化机制。

尾调用：在一个函数体的末尾，调用另外一个函数。

es5里的尾调用：在尾部创建栈帧，把函数推入新栈帧来表示调用，在循环调用里，每一个没用完的栈帧都保存在内存里

es6里的尾调用：缩减严格模式里

